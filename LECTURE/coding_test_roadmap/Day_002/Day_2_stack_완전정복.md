# Day 2 — 스택(Stack) 완전 정복

목표
- 스택이 필요한 문제를 **문제 읽는 단계에서 즉시 판별**한다.
- 스택 문제를 **유형별로 분류**하고, 각 유형에 맞는 **고정 코드 패턴**을 적용한다.
- 실전에서 자주 발생하는 **오답·시간초과를 구조적으로 차단**한다.

---

## 1. 코딩테스트에서 스택의 본질

### 시험 관점 정의
스택은 단순한 LIFO 자료구조가 아니라,
> **이전에 했던 판단을, 필요해질 때까지 보관했다가 가장 최근 것부터 되돌려 쓰는 구조**

핵심 키워드: **되돌아가기(rollback)**

스택은 다음 상황에서 필수다.
- 이전 상태가 이후 상태에 의해 무효화됨
- 조건이 깨질 때마다 과거 상태로 연쇄적으로 복귀해야 함
- 중첩 구조의 올바른 순서를 검증해야 함

---

## 2. Python에서의 스택 구현 규칙

### 기본 구현 (시험 표준)
```python
stack = []
stack.append(x)  # push
stack.pop()      # pop
```

- `append`, `pop` (맨 뒤)만 사용 → O(1)
- `pop(0)`, `insert(0, x)` → **절대 사용 금지** (O(N))

### 안전한 접근 규칙
```python
while stack and 조건:
    stack.pop()
```
- 항상 `stack` 존재 여부를 먼저 확인
- `if`가 아니라 **`while`이 기본값**

---

## 3. 스택 문제의 3가지 핵심 유형

### 유형 1. 이전 값이 현재 값에 의해 처리되는 유형

#### 구조적 특징
- 수열 문제
- "가장 가까운", "처음으로", "왼쪽/오른쪽" 같은 표현 등장
- 현재 값이 등장하면서 이전 값들이 한꺼번에 쓸모없어짐

#### 판단 문장
> 앞에 있던 값들이, 뒤에 오는 값 하나 때문에 한 번에 제거될 수 있다.

#### 고정 패턴
```python
for x in data:
    while stack and stack[-1] < x:
        stack.pop()
    stack.append(x)
```

대표 문제 예시
- BOJ 2493 탑
- BOJ 17298 오큰수

---

### 유형 2. 조건을 만족할 때까지 되돌아가는 유형

#### 구조적 특징
- "조건을 만족할 때까지"
- "더 이상 가능하지 않을 때까지"
- 연쇄적으로 이전 상태를 재검사

#### 판단 문장
> 지금 상태가 안 되면, 그 이전 상태도 다시 봐야 한다.

#### 고정 패턴
```python
while stack and 조건:
    stack.pop()
```

대표 문제 예시
- 문자열 폭발
- 중복 제거 계열 문제

---

### 유형 3. 구조(중첩) 검증 유형

#### 구조적 특징
- 괄호, 태그, 중첩 구조
- 개수가 아니라 **순서**가 핵심

#### 판단 문장
> 가장 마지막에 열린 것이, 가장 먼저 닫혀야 한다.

#### 고정 패턴
```python
for ch in s:
    if ch == '(':
        stack.append(ch)
    else:
        if not stack:
            return False
        stack.pop()

return not stack
```

대표 문제 예시
- BOJ 9012 괄호
- 쇠막대기

---

## 4. 실전 대표 문제 요약

### BOJ 2493 — 탑 (유형 1)

핵심 아이디어
- 현재 탑보다 낮은 탑은 이후에도 절대 수신 대상이 될 수 없음
- 따라서 스택에서 제거

저장 정보
- (높이, 인덱스)

시간복잡도 증명
- 각 원소는 최대 1회 push, 1회 pop → O(N)

---

### BOJ 9012 — 괄호 (유형 3)

핵심 아이디어
- 닫는 괄호에서 스택이 비어 있으면 즉시 실패
- 모든 문자를 처리한 뒤 스택이 비어 있어야 성공

실수 포인트
- 개수만 세는 접근은 항상 실패
- 마지막 스택 비움 체크 필수

---

## 5. 스택 문제 오답·시간초과 패턴

### 자주 발생하는 실수
1. 유형 분류 실패 (제거 vs 검증 혼동)
2. `if`로 처리해 연쇄 pop 실패
3. 빈 스택 체크 누락 → 런타임 에러
4. 스택에 필요한 정보(인덱스 등) 누락
5. O(N) 구조에서 불필요한 O(N) 연산 삽입

---

## 6. 실전 체크리스트 (문제 풀기 전)

### 문제 읽기 단계
- [ ] "가장 가까운 / 처음"이 있는가?
- [ ] "조건을 만족할 때까지 제거"가 있는가?
- [ ] "짝 / 중첩 / 올바른 구조"인가?

### 설계 단계
- [ ] 스택 유형 (1/2/3)을 명확히 분류했는가?
- [ ] 스택에 어떤 정보를 저장할지 결정했는가?

### 구현 단계
- [ ] `while stack and ...` 순서 지켰는가?
- [ ] 마지막에 스택 상태를 확인했는가?

---

## 7. Day 2 핵심 요약

- 스택 문제는 **유형 분류가 80%**
- 코드보다 먼저, "왜 스택인가"를 말로 설명할 수 있어야 함
- 스택 문제는 대부분 O(N), 느리면 접근이 틀린 것

---

## 다음 단계 예고

Day 3 — 큐(Queue) / 덱(Deque)
- 순서 유지 문제
- BFS의 기반 구조
- 스택과의 구조적 차이 비교

